C51 COMPILER V9.00   MAIN                                                                  01/02/2019 18:19:00 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: H:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

*** WARNING C500 IN LINE 1 OF MAIN.C: LICENSE ERROR (R208: RENEW LICENSE ID CODE (LIC))

   1          #include <reg52.h>                      // 包含头文件
   2          #include <intrins.h>
   3          
   4          #define uchar unsigned char             // 以后unsigned char就可以用uchar代替
   5          #define uint  unsigned int              // 以后unsigned int 就可以用uint 代替
   6          
   7          
   8          sbit w1 = P2^4;                                 // 数码管第1位的控制引脚
   9          sbit w2 = P2^5;                         // 数码管第2位的控制引脚
  10          sbit w3 = P2^6;                         // 数码管第3位的控制引脚
  11          sbit w4 = P2^7;                         // 数码管第4位的控制引脚
  12          sbit DQ1 = P1^0;                                // 第一个DS18B20传感器的引脚定义
  13          sbit DQ2 = P2^1;                                // 第二个DS18B20传感器的引脚定义
  14          sbit LedLow  = P1^2;                    // 温度过低指示灯
  15          sbit LedHig  = P1^4;                    // 温度过高指示灯
  16          sbit Buzzer  = P2^3;                    // 蜂鸣器引脚
  17          sbit KeySet  = P3^2;                    // 设置按键
  18          sbit KeyDown = P3^3;                    // 减按键
  19          sbit KeyUp   = P3^4;                    // 加按键
  20          
  21          uchar DQ_switch = 0;                    //温度传感器选择  0：第一个  1：第二个
  22          
  23          /*   数码管的显示值 0   1   2   3   4    5   6   7   8   9   -   */
  24          uchar code Array1[]={ 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x40 };
  25          
  26          /*                 0.   1.   2.   3.  4.   5.   6.  7.   8.  9.  */
  27          uchar code Array2[]={ 0xBf,0x86,0xdb,0xcf,0xe6,0xed,0xfd,0x87,0xff,0xef };
  28          
  29          uchar Buff[4];                                  // 显示缓冲区
  30          uchar ShowID=1;                         // 当前显示的是哪一个数码管
  31          int AlarmLow=120;                               // 默认报警的温度下限值是12度
  32          int AlarmHig=320;                               // 默认报警的温度上限值是32度
  33          
  34          /*********************************************************/
  35          // 毫秒级的延时函数，time是要延时的毫秒数
  36          /*********************************************************/
  37          void DelayMs(uint time)
  38          {
  39   1              uint i,j;
  40   1              for(i=0;i<time;i++)
  41   1                      for(j=0;j<112;j++);
  42   1      }
  43          
  44          /*********************************************************/
  45          // 延时15微秒
  46          /*********************************************************/
  47          void Delay15us(void)
  48          {
  49   1              _nop_();
  50   1              _nop_();
  51   1              _nop_();
  52   1              _nop_();
  53   1              _nop_();
  54   1              _nop_();
C51 COMPILER V9.00   MAIN                                                                  01/02/2019 18:19:00 PAGE 2   

  55   1              _nop_();
  56   1              _nop_();
  57   1              _nop_();
  58   1              _nop_();
  59   1              _nop_();
  60   1              _nop_();
  61   1              _nop_();
  62   1              _nop_();
  63   1              _nop_();
  64   1      }
  65          
  66          /*********************************************************/
  67          // 复位DS18B20（初始化）        DQ1：第一个温度传感器
  68          /*********************************************************/
  69          void DQ1_ReSet(void)
  70          {
  71   1              uchar i;
  72   1              DQ1=0;
  73   1              i=240;
  74   1              while(--i);
  75   1              DQ1=1;
  76   1              i=30;
  77   1              while(--i);
  78   1              while(~DQ1);
  79   1              i=4;
  80   1              while(--i);
  81   1      }
  82          
  83          /*********************************************************/
  84          // 向DS18B20写入一个字节        DQ1：第一个温度传感器
  85          /*********************************************************/
  86          void DQ1_WriteByte(uchar dat)
  87          {
  88   1              uchar j;
  89   1              uchar btmp;
  90   1              
  91   1              for(j=0;j<8;j++)
  92   1              {
  93   2                      btmp=0x01;
  94   2                      btmp=btmp<<j;
  95   2                      btmp=btmp&dat;
  96   2                      
  97   2                      if(btmp>0)              // 写1
  98   2                      {
  99   3                              DQ1=0;
 100   3                              Delay15us();
 101   3                              DQ1=1;
 102   3                              Delay15us();
 103   3                              Delay15us();
 104   3                              Delay15us();
 105   3                              Delay15us();
 106   3                      }
 107   2                      else                    // 写0
 108   2                      {
 109   3                              DQ1=0;
 110   3                              Delay15us();
 111   3                              Delay15us();
 112   3                              Delay15us();
 113   3                              Delay15us();
 114   3                              DQ1=1;
 115   3                              Delay15us();
 116   3                      }
C51 COMPILER V9.00   MAIN                                                                  01/02/2019 18:19:00 PAGE 3   

 117   2              }
 118   1      }
 119          
 120          /*********************************************************/
 121          // 读取DQ1温度值                DQ1：第一个温度传感器
 122          /*********************************************************/
 123          int DQ1_ReadTemp(void)
 124          {
 125   1              uchar j;
 126   1              int b,temp=0;   
 127   1      
 128   1              DQ1_ReSet();                                    // 产生复位脉
 129   1              DQ1_WriteByte(0xcc);                    // 忽略ROM指令
 130   1              DQ1_WriteByte(0x44);                    // 启动温度转换指令
 131   1              DQ1_ReSet();                                    // 产生复位脉
 132   1              DQ1_WriteByte(0xcc);                    // 忽略ROM指令
 133   1              DQ1_WriteByte(0xbe);                    // 读取温度指令
 134   1      
 135   1              for(j=0;j<16;j++)                                       // 读取温度数量
 136   1              {                                               
 137   2                      DQ1=0;
 138   2                      _nop_();
 139   2                      _nop_();
 140   2                      DQ1=1;  
 141   2                      Delay15us();
 142   2                      b=DQ1;
 143   2                      Delay15us();
 144   2                      Delay15us();
 145   2                      Delay15us();
 146   2                      b=b<<j;
 147   2                      temp=temp|b;
 148   2              }
 149   1              temp=temp*0.0625*10;                            // 合成温度值并放大10倍                                 
 150   1              return (temp);                                          // 返回检测到的温度值
 151   1      }
 152          
 153          
 154          /*********************************************************/
 155          // 复位DS18B20（初始化）          DQ2：第二个温度传感器
 156          /*********************************************************/
 157          void DQ2_ReSet(void)
 158          {
 159   1              uchar i;
 160   1              DQ2=0;
 161   1              i=240;
 162   1              while(--i);
 163   1              DQ2=1;
 164   1              i=30;
 165   1              while(--i);
 166   1              while(~DQ2);
 167   1              i=4;
 168   1              while(--i);
 169   1      }
 170          
 171          /*********************************************************/
 172          // 向DS18B20写入一个字节         DQ2：第二个温度传感器
 173          /*********************************************************/
 174          void DQ2_WriteByte(uchar dat)
 175          {
 176   1              uchar j;
 177   1              uchar btmp;
 178   1              
C51 COMPILER V9.00   MAIN                                                                  01/02/2019 18:19:00 PAGE 4   

 179   1              for(j=0;j<8;j++)
 180   1              {
 181   2                      btmp=0x01;
 182   2                      btmp=btmp<<j;
 183   2                      btmp=btmp&dat;
 184   2                      
 185   2                      if(btmp>0)              // 写1
 186   2                      {
 187   3                              DQ2=0;
 188   3                              Delay15us();
 189   3                              DQ2=1;
 190   3                              Delay15us();
 191   3                              Delay15us();
 192   3                              Delay15us();
 193   3                              Delay15us();
 194   3                      }
 195   2                      else                    // 写0
 196   2                      {
 197   3                              DQ2=0;
 198   3                              Delay15us();
 199   3                              Delay15us();
 200   3                              Delay15us();
 201   3                              Delay15us();
 202   3                              DQ2=1;
 203   3                              Delay15us();
 204   3                      }
 205   2              }
 206   1      }
 207          
 208          /*********************************************************/
 209          // 读取DQ2温度值                DQ2：第二个温度传感器
 210          /*********************************************************/
 211          int DQ2_ReadTemp(void)
 212          {
 213   1              uchar j;
 214   1              int b,temp=0;   
 215   1      
 216   1              DQ2_ReSet();                                    // 产生复位脉
 217   1              DQ2_WriteByte(0xcc);                    // 忽略ROM指令
 218   1              DQ2_WriteByte(0x44);                    // 启动温度转换指令
 219   1              DQ2_ReSet();                                    // 产生复位脉
 220   1              DQ2_WriteByte(0xcc);                    // 忽略ROM指令
 221   1              DQ2_WriteByte(0xbe);                    // 读取温度指令
 222   1      
 223   1              for(j=0;j<16;j++)                                       // 读取温度数量
 224   1              {                                               
 225   2                      DQ2=0;
 226   2                      _nop_();
 227   2                      _nop_();
 228   2                      DQ2=1;  
 229   2                      Delay15us();
 230   2                      b=DQ2;
 231   2                      Delay15us();
 232   2                      Delay15us();
 233   2                      Delay15us();
 234   2                      b=b<<j;
 235   2                      temp=temp|b;
 236   2              }
 237   1              temp=temp*0.0625*10;                            // 合成温度值并放大10倍                                 
 238   1              return (temp);                                          // 返回检测到的温度值
 239   1      }
 240          
C51 COMPILER V9.00   MAIN                                                                  01/02/2019 18:19:00 PAGE 5   

 241          /*********************************************************/
 242          // 定时器初始化
 243          /*********************************************************/
 244          void TimerInit()
 245          {
 246   1              TMOD = 0x01;                                            // 使用定时器0，工作方式1        
 247   1              TH0  = 248;                                             // 给定时器0的TH0装初值
 248   1              TL0  = 48;                                              // 给定时器0的TL0装初值
 249   1              ET0  = 1;                                                       // 定时器0中断使能
 250   1              EA   = 1;                                               // 打开总中断
 251   1              TR0      = 1;                                                   // 启动定时器0
 252   1      }
 253          
 254          /*********************************************************/
 255          // 显示温度值
 256          /*********************************************************/
 257          void ShowTemp(int dat)
 258          {
 259   1              if(dat<0)                                                       // 负号
 260   1              {
 261   2                      Buff[0]=Array1[10];
 262   2                      dat=0-dat;
 263   2              }
 264   1              else                                                            // 百位
 265   1              {
 266   2                      Buff[0]=Array1[dat/1000];
 267   2              }
 268   1              
 269   1              Buff[1]=Array1[dat%1000/100];           // 十位
 270   1              Buff[2]=Array2[dat%100/10];                     // 个位
 271   1              Buff[3]=Array1[dat%10];                         // 小数后一位
 272   1      }
 273          
 274          /*********************************************************/
 275          // 报警判断
 276          /*********************************************************/
 277          void AlarmJudge(int dat)
 278          {
 279   1              if(dat<AlarmLow)                                                // 判断温度是否过低
 280   1              {
 281   2                      LedLow=0;
 282   2                      LedHig=1;
 283   2                      Buzzer=0;
 284   2              }
 285   1              else if(dat>AlarmHig)                                   // 判断温度是否过高
 286   1              {
 287   2                      LedLow=1;
 288   2                      LedHig=0;
 289   2                      Buzzer=0;
 290   2              }
 291   1              else                                                                    // 温度正常
 292   1              {
 293   2                      LedLow=1;
 294   2                      LedHig=1;
 295   2                      Buzzer=1;
 296   2              }
 297   1      }
 298          
 299          /*********************************************************/
 300          // 按键扫描
 301          /*********************************************************/
 302          void KeyScanf()
C51 COMPILER V9.00   MAIN                                                                  01/02/2019 18:19:00 PAGE 6   

 303          {
 304   1              static uchar Key_set_num = 0;
 305   1              uchar Break_flag = 0;
 306   1              if(KeySet==0)                                                   // 如果设置按键被按下
 307   1              {
 308   2                      DelayMs(10);                                            // 延时去抖
 309   2                      if(KeySet == 0)
 310   2                      {
 311   3                              while(!KeySet);                                 // 等待按键释放
 312   3                              Key_set_num ++;                                 //功能键计数
 313   3                                      
 314   3                      }
 315   2                      
 316   2              }
 317   1              if(Key_set_num ==0)
 318   1              {
 319   2                       DQ_switch = 0;                                         //选择第一个温度传感器
 320   2              }
 321   1              else if(Key_set_num == 1)
 322   1              {
 323   2                      DQ_switch = 1;                                          //选择第二个温度传感器
 324   2              }
 325   1              else if(Key_set_num == 2)
 326   1              {
 327   2                      /* 设置温度下限 */
 328   2                      LedLow=0;                                                       // 点亮绿色灯（代表当前正在设置温度下限）
 329   2                      LedHig=1;                                                       // 熄灭红色灯
 330   2                      Buzzer=1;                                                       // 关闭蜂鸣器
 331   2                      ShowTemp(AlarmLow);                                     // 显示温度下限值
 332   2                      DelayMs(10);                                            // 延时去抖
 333   2                      while(!KeySet);                                         // 等待按键释放
 334   2                      DelayMs(10);                                            // 延时去抖
 335   2                      
 336   2                      while(1)
 337   2                      {
 338   3                              if(KeyDown==0)                                  // 如果“减”按键被按下
 339   3                              {
 340   4                                      if(AlarmLow>-550)                       // 判断当前温度下限是否大于-55度
 341   4                                      {
 342   5                                              AlarmLow--;                             // 温度下限值减去0.1度
 343   5                                              ShowTemp(AlarmLow);             // 刷新显示改变后的温度下限值
 344   5                                              DelayMs(200);                   // 延时
 345   5                                      }
 346   4                              }
 347   3                              
 348   3                              if(KeyUp==0)                                    // 如果“加”按键被按下                                 
 349   3                              {
 350   4                                      if(AlarmLow<1250)                       // 判断当前温度下限是否小于125度
 351   4                                      {
 352   5                                              AlarmLow++;                             // 温度下限值加上0.1度
 353   5                                              ShowTemp(AlarmLow);             // 刷新显示改变后的温度下限值
 354   5                                              DelayMs(200);                   // 延时
 355   5                                      }
 356   4                              }
 357   3                              
 358   3                              if(KeySet==0)                                   // 如果“设置”按键被按下
 359   3                              {
 360   4                                      Key_set_num = 3;
 361   4                                      break;
 362   4                              }
 363   3                      }
 364   2                      /* 退出设置模式 */
C51 COMPILER V9.00   MAIN                                                                  01/02/2019 18:19:00 PAGE 7   

 365   2                      LedLow=1;                                                       // 熄灭绿灯
 366   2                      LedHig=1;                                                       // 熄灭红灯
 367   2                      DelayMs(10);                                            // 延时去抖
 368   2                      while(!KeySet);                                         // 等待按键释放
 369   2                      DelayMs(10);                                            // 延时去抖
 370   2              }
 371   1              
 372   1              if(Key_set_num == 3)
 373   1              {
 374   2                      /* 设置温度上限 */
 375   2                      LedLow=1;                                                       // 熄灭绿色灯
 376   2                      LedHig=0;                                                       // 点亮红色灯（代表当前正在设置温度上限）
 377   2                      ShowTemp(AlarmHig);                                     // 显示温度上限值
 378   2                      DelayMs(10);                                            // 延时去抖
 379   2                      while(!KeySet);                                         // 等待按键释放
 380   2                      DelayMs(10);                                            // 延时去抖
 381   2                      
 382   2                      while(1)
 383   2                      {
 384   3                              if(KeyDown==0)                                  // 如果“减”按键被按下                                                 
 385   3                              {
 386   4                                      if(AlarmHig>-550)                       // 判断当前温度上限是否大于-55度
 387   4                                      {
 388   5                                              AlarmHig--;                             // 温度上限值减去0.1度
 389   5                                              ShowTemp(AlarmHig);             // 刷新显示改变后的温度上限值
 390   5                                              DelayMs(200);                   // 延时
 391   5                                      }
 392   4                              }
 393   3                              
 394   3                              if(KeyUp==0)                                    // 如果“加”按键被按下                                 
 395   3                              {
 396   4                                      if(AlarmHig<1250)                       // 判断当前温度上限是否小于125度
 397   4                                      {
 398   5                                              AlarmHig++;                             // 温度上限值加上0.1度
 399   5                                              ShowTemp(AlarmHig);             // 刷新显示改变后的温度上限值
 400   5                                              DelayMs(200);
 401   5                                      }
 402   4                              }
 403   3                              
 404   3                              if(KeySet==0)                                   // 如果“设置”按键被按下
 405   3                              {
 406   4                                      Key_set_num = 0;
 407   4                                      DQ_switch = 0;
 408   4                                      break;                                          // 准备退出设置模式
 409   4                              }
 410   3                      }
 411   2                      /* 退出设置模式 */
 412   2                      LedLow=1;                                                       // 熄灭绿灯
 413   2                      LedHig=1;                                                       // 熄灭红灯
 414   2                      DelayMs(10);                                            // 延时去抖
 415   2                      while(!KeySet);                                         // 等待按键释放
 416   2                      DelayMs(10);                                            // 延时去抖
 417   2              }
 418   1      }
 419          
 420          /*********************************************************/
 421          // 主函数
 422          /*********************************************************/
 423          void main()
 424          {
 425   1              int temp;
 426   1              uchar i;
C51 COMPILER V9.00   MAIN                                                                  01/02/2019 18:19:00 PAGE 8   

 427   1              
 428   1              TimerInit();                                            // 定时器0的初始化（数码管的动态扫描）
 429   1              
 430   1              Buff[0]=Array1[0];                                      // 刚上电显示4个0
 431   1              Buff[1]=Array1[0];
 432   1              Buff[2]=Array1[0];
 433   1              Buff[3]=Array1[0];
 434   1              
 435   1              for(i=0;i<8;i++)        // 传感器刚上电读出的温度不稳定，因此先进行几次读取并丢弃
 436   1              {
 437   2                      DQ1_ReadTemp();
 438   2                      DQ2_ReadTemp();
 439   2                      DelayMs(120);
 440   2              }
 441   1      
 442   1              while(1)
 443   1              {
 444   2                      EA=0;                                                   // 屏蔽中断
 445   2                      if(DQ_switch == 0 )
 446   2                              temp=DQ1_ReadTemp();            // 读取第一个DS18B20温度值
 447   2                      else 
 448   2                              temp=DQ2_ReadTemp();            // 读取第二个DS18B20温度值
 449   2                      EA=1;                                                   // 恢复中断
 450   2                      
 451   2                      ShowTemp(temp);                                 // 显示温度值
 452   2                      
 453   2                      AlarmJudge(temp);                               // 判断是否需要报警
 454   2                      
 455   2                      for(i=0;i<100;i++)                              // 延时并进行按键扫描
 456   2                      {
 457   3                              KeyScanf();                                     
 458   3                              DelayMs(10);                                                            
 459   3                      }
 460   2              }
 461   1      }
 462          
 463          /*********************************************************/
 464          // 定时器0服务程序
 465          /*********************************************************/
 466          void Timer0(void) interrupt 1
 467          {
 468   1              TH0  = 248;                             // 给定时器0的TH0装初值
 469   1              TL0  = 48;                              // 给定时器0的TL0装初值
 470   1      
 471   1              P0=0x00;                                        // 先关闭所有显示
 472   1              w1=1;
 473   1              w2=1;
 474   1              w3=1;
 475   1              w4=1;
 476   1      
 477   1              if(ShowID==1)                   // 判断是否显示第1位数码管
 478   1              {
 479   2                      w1=0;                           // 打开第1位数码管的控制开关
 480   2                      P0=Buff[0];                     // 第1位数码管显示内容  
 481   2              }
 482   1              
 483   1              if(ShowID==2)                   // 判断是否显示第2位数码管
 484   1              {
 485   2                      w2=0;                           // 打开第2位数码管的控制开关
 486   2                      P0=Buff[1];                     // 第2位数码管显示内容  
 487   2              }
 488   1              
C51 COMPILER V9.00   MAIN                                                                  01/02/2019 18:19:00 PAGE 9   

 489   1              if(ShowID==3)                   // 判断是否显示第3位数码管
 490   1              {
 491   2                      w3=0;                           // 打开第3位数码管的控制开关
 492   2                      P0=Buff[2];                     // 第3位数码管显示内容  
 493   2              }
 494   1              
 495   1              if(ShowID==4)                   // 判断是否显示第4位数码管
 496   1              {
 497   2                      w4=0;                           // 打开第4位数码管的控制开关
 498   2                      P0=Buff[3];                     // 第4位数码管显示内容  
 499   2              }       
 500   1              
 501   1              ShowID++;                               // 切换到下一个数码管的显示
 502   1              if(ShowID==5)
 503   1                      ShowID=1;
 504   1      }
 505          
 506          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1066    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
